from Crypto.Util.number import bytes_to_long, long_to_bytes, getPrime, getRandomRange, inverse
from secret import flag

assert len(flag)==40
p = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFF0000000000000000FFFFFFFF
a = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFF0000000000000000FFFFFFFC
b = 0xB3312FA7E23EE7E4988E056BE3F82D19181D9C6EFE8141120314088F5013875AC656398D8A2ED19D2A85C8EDD3EC2AEF

Gx = 0xAA87CA22BE8B05378EB1C71EF320AD746E1D3B628BA79B9859F741E082542A385502F25DBF55296C3A545E3872760AB7
Gy = 0x3617DE4A96262C6F5D9E98BF9292DC29F8F41DBD289A147CE9DA3113B5F0B8C00A60B1CE1D7E819D7A431D7C90EA0E5F

def padding(s):
    return s+bytes.fromhex(hex(80-len(s))[2:])*(80-len(s))

class task():
    def __init__(self):
        self.E = EllipticCurve(IntegerModRing(p), [a, b])
        self.l = getRandomRange(1, p)
        self.P = self.E.point((Gx, Gy))
        self.Q = self.l*self.P
        
    def Enc(self, m1, m2):
        self.k = getRandomRange(2, p-2)
        R = self.k*self.P
        T = self.k*self.Q
        x1, y1 = T.xy()
        x2, y2 = x1*m1%p, y1*m2%p
        return (R, x2, y2)

    def Dec(self, R, x2, y2):
        x1, y1 = (self.l*R).xy()
        m1, m2 = x2*inverse(x1, p)%p, y2*inverse(y1, p)%p
        return (m1, m2)
flag = padding(flag)
M = (bytes_to_long(flag[:len(flag)//2]), bytes_to_long(flag[len(flag)//2:]))
cip = task()
R, x2, y2 = cip.Enc(*M)

print(f"R : {R}")
print(f"x2 : {x2}")
print(f"y2 : {y2}")

# R : (34259415888420137132517508014291908993513756302392481296329862476485690264525419099286276892151206245248060169611696 : 16146752142834680585388696105812248532868349062542704009373024020683391045124465225063060810458653038820500500919932 : 1)
# x2 : 32178814692003971705213515764388456967717784223720317564762588386607673563051885976666474195031661163956294657905720
# y2 : 31690679105042319503912561619670638646395635034408865257977054851398742766198858123159167391490327333045446233169033
